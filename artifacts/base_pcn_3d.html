<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Base PCN Algebraic Security - 3D Module Graph</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #1a1a2e; }
        #info {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px;
            max-width: 350px; font-size: 14px;
        }
        #info h2 { margin-top: 0; color: #4fc3f7; }
        #legend {
            position: absolute; bottom: 10px; left: 10px; color: white;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px;
        }
        .legend-item { display: flex; align-items: center; margin: 5px 0; }
        .legend-color { width: 20px; height: 20px; margin-right: 10px; border-radius: 3px; }
        #tooltip {
            position: absolute; display: none; background: rgba(0,0,0,0.9);
            color: white; padding: 10px; border-radius: 5px; font-size: 13px;
            pointer-events: none; max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>Base PCN Algebraic Security</h2>
        <p>Machine-verified proofs for Payment Channel Networks on Coinbase's Base blockchain.</p>
        <p><strong>Main Result:</strong> Wealth feasibility â†” cut constraints</p>
        <p>Drag to rotate, scroll to zoom.</p>
    </div>
    <div id="legend">
        <div class="legend-item"><div class="legend-color" style="background:#4fc3f7"></div>Core PCN Geometry</div>
        <div class="legend-item"><div class="legend-color" style="background:#66bb6a"></div>Base EVM Adapter</div>
        <div class="legend-item"><div class="legend-color" style="background:#ffb74d"></div>Security Infrastructure</div>
        <div class="legend-item"><div class="legend-color" style="background:#ba68c8"></div>Post-Quantum Crypto</div>
    </div>
    <div id="tooltip"></div>

    <script>
        const nodes = [
            // Core PCN Geometry (blue) - layer 0
            { id: 'Basic', label: 'Basic', group: 'core', x: 0, y: 0, z: 0 },
            { id: 'Graph', label: 'Graph', group: 'core', x: 0, y: 1, z: 0 },
            { id: 'Liquidity', label: 'Liquidity', group: 'core', x: 0, y: 2, z: 0 },
            { id: 'Wealth', label: 'Wealth', group: 'core', x: 0, y: 3, z: 0 },
            { id: 'Cuts', label: 'Cuts', group: 'core', x: 0, y: 4, z: 0 },
            { id: 'AlgorithmicCuts', label: 'AlgorithmicCuts', group: 'core', x: 0, y: 5, z: 0 },
            { id: 'CutCompleteness', label: 'CutCompleteness\n(MAIN THEOREM)', group: 'core', x: 0, y: 6, z: 0, main: true },
            { id: 'Rebalancing', label: 'Rebalancing', group: 'core', x: -1, y: 4, z: 0 },
            { id: 'Quotient', label: 'Quotient', group: 'core', x: 0, y: 7, z: 0 },
            { id: 'Algorithmic', label: 'Algorithmic', group: 'core', x: 1, y: 6, z: 0 },

            // EVM Adapter (green) - layer 1
            { id: 'ContractsModel', label: 'Contracts.Model', group: 'evm', x: 2, y: 0, z: 1 },
            { id: 'EVMState', label: 'EVMAdapter.State', group: 'evm', x: 2, y: 1, z: 1 },
            { id: 'FromEVMState', label: 'FromEVMState', group: 'evm', x: 2, y: 2, z: 1 },
            { id: 'Extractor', label: 'Extractor', group: 'evm', x: 2, y: 3, z: 1 },
            { id: 'SettlementOps', label: 'SettlementOps', group: 'evm', x: 3, y: 2, z: 1 },
            { id: 'SettlementSemantics', label: 'SettlementSemantics', group: 'evm', x: 2.5, y: 4, z: 1 },
            { id: 'SeamTheorem', label: 'SeamTheorem', group: 'evm', x: 2, y: 5.5, z: 1 },

            // Security (orange) - layer 2
            { id: 'MessageModelSeq', label: 'MessageModelSeq', group: 'security', x: -2, y: 2, z: 2 },
            { id: 'PostQuantumHTLC', label: 'PostQuantumHTLC', group: 'security', x: -2, y: 4, z: 2 },

            // Crypto (purple) - layer 2
            { id: 'XMSS', label: 'XMSS', group: 'crypto', x: -3, y: 2, z: 2.5 },
            { id: 'IncomparableEncoding', label: 'IncomparableEncoding', group: 'crypto', x: -3, y: 1, z: 2.5 },
        ];

        const edges = [
            // Core
            ['Basic', 'Graph'],
            ['Graph', 'Liquidity'],
            ['Liquidity', 'Wealth'],
            ['Wealth', 'Cuts'],
            ['Cuts', 'AlgorithmicCuts'],
            ['AlgorithmicCuts', 'CutCompleteness'],
            ['AlgorithmicCuts', 'Algorithmic'],
            ['Liquidity', 'Rebalancing'],
            ['Wealth', 'Rebalancing'],
            ['Wealth', 'Quotient'],
            ['CutCompleteness', 'Quotient'],

            // EVM
            ['ContractsModel', 'EVMState'],
            ['EVMState', 'FromEVMState'],
            ['FromEVMState', 'Extractor'],
            ['Graph', 'Extractor'],
            ['EVMState', 'SettlementOps'],
            ['SettlementOps', 'SettlementSemantics'],
            ['Extractor', 'SettlementSemantics'],
            ['SettlementSemantics', 'SeamTheorem'],
            ['CutCompleteness', 'SeamTheorem'],

            // Security
            ['MessageModelSeq', 'PostQuantumHTLC'],
            ['XMSS', 'PostQuantumHTLC'],
            ['Graph', 'PostQuantumHTLC'],
        ];

        const groupColors = {
            core: 0x4fc3f7,
            evm: 0x66bb6a,
            security: 0xffb74d,
            crypto: 0xba68c8,
        };

        // Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // Create nodes
        const nodeMeshes = {};
        const nodeMap = {};
        nodes.forEach(node => {
            nodeMap[node.id] = node;
            const size = node.main ? 0.6 : 0.4;
            const geometry = new THREE.SphereGeometry(size, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: groupColors[node.group],
                emissive: groupColors[node.group],
                emissiveIntensity: 0.2,
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(node.x * 1.5, node.y * 1.2, node.z * 2);
            mesh.userData = node;
            scene.add(mesh);
            nodeMeshes[node.id] = mesh;
        });

        // Create edges
        edges.forEach(([from, to]) => {
            const start = nodeMeshes[from].position;
            const end = nodeMeshes[to].position;
            const points = [start, end];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0x666666,
                transparent: true,
                opacity: 0.6
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
        });

        // Tooltip
        const tooltip = document.getElementById('tooltip');
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Object.values(nodeMeshes));

            if (intersects.length > 0) {
                const node = intersects[0].object.userData;
                tooltip.style.display = 'block';
                tooltip.style.left = event.clientX + 15 + 'px';
                tooltip.style.top = event.clientY + 15 + 'px';
                tooltip.innerHTML = `<strong>${node.label}</strong><br>Group: ${node.group}`;
            } else {
                tooltip.style.display = 'none';
            }
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
